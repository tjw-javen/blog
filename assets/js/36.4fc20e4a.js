(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{440:function(v,_,t){v.exports=t.p+"assets/img/https.5596ab39.png"},585:function(v,_,t){"use strict";t.r(_);var e=t(54),o=Object(e.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"关于-http"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于-http"}},[v._v("#")]),v._v(" 关于 Http")]),v._v(" "),e("p",[v._v("关于 tcp握手/挥手 相关内容在 "),e("RouterLink",{attrs:{to:"/other/browser/page_load.html"}},[v._v("从输入URL到页面加载过程")])],1),v._v(" "),e("p",[e("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview",target:"_blank",rel:"noopener noreferrer"}},[v._v("参考"),e("OutboundLink")],1)]),v._v(" "),e("h3",{attrs:{id:"从-http1-0-到-http1-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从-http1-0-到-http1-1"}},[v._v("#")]),v._v(" 从 http1.0 到 http1.1")]),v._v(" "),e("p",[v._v("在浏览器中，越来越多的使用更多的图片和更多的懒加载组件，然后会导致页面加载时会加载很多的几kb文件，")]),v._v(" "),e("p",[v._v("因此 http 经过了好几代的更新。")]),v._v(" "),e("p",[v._v("从古老的 http1.0 开始，它存在的以下的问题")]),v._v(" "),e("ol",[e("li",[v._v("在http1.0中，发送一次请求时，需要等待服务端响应了才可以继续发送请求。")]),v._v(" "),e("li",[v._v("连接方式是短链接")])]),v._v(" "),e("p",[v._v("为了解决上述 http1.0 的问题，出现了 http 1.1，它主要做了以下改动")]),v._v(" "),e("ol",[e("li",[v._v("持久连接：出现了默认长连接方式 "),e("code",[v._v("keep-alive")])]),v._v(" "),e("li",[v._v("请求管道化：发送一次请求时，不需要等待服务端响应了就可以发送请求了。\n"),e("ul",[e("li",[v._v("理想情况中 HTTP 请求管道化（流水线）启动时，后续请求都可以不用等待第一个请求的成功响应就被发送。")]),v._v(" "),e("li",[v._v("然而HTTP管道化，很难在现有网络中有很多老旧的软件与现代版本的软件共存")])])]),v._v(" "),e("li",[v._v("增加缓存处理：新的字段如 "),e("code",[v._v("cache-control")])]),v._v(" "),e("li",[v._v("增加Host字段、支持断点传输等")])]),v._v(" "),e("p",[e("code",[v._v("keep-alive")]),v._v("：在规定时间内，同一域名多次请求数据，只建立一次HTTP请求，后续请求可复用之前的连接通道。该规定时间默认为"),e("code",[v._v("2小时")]),v._v("，可以通过 "),e("code",[v._v("Apache")]),v._v(" 或者 "),e("code",[v._v("nginx")]),v._v(" 配置。")]),v._v(" "),e("p",[v._v("但是，http1.1的问题依然存在")]),v._v(" "),e("ol",[e("li",[v._v("在 http1.1中，基于请求-响应的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞，服务器回送数据给客户端的时候，客户端需要按照响应的顺序来一一接收。也就是"),e("strong",[v._v("线头阻塞")]),v._v("。")]),v._v(" "),e("li",[v._v("在 http1.1 中无论是请求还是响应都是"),e("strong",[v._v("基于文本")]),v._v("的，在数据传输的过程中服务器并不知道字符的顺序。所以：keep-alive 对于单文件的传输是block级的，数据必须按顺序传输，不能并行。")])]),v._v(" "),e("h3",{attrs:{id:"从-http1-1-到-http2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从-http1-1-到-http2"}},[v._v("#")]),v._v(" 从 http1.1 到 http2")]),v._v(" "),e("p",[v._v("2015年 出现了 http2， 它在 http1.1 语法和底层传输协议之间增加了一个新的中间层，而没有从根本上修改它，即它是建立在经过验证的机制之上，这个中间层就是帧机制。它引入 "),e("code",[v._v("二进制数据帧")]),v._v(" 和 "),e("code",[v._v("流")]),v._v(" 的概念，"),e("strong",[v._v("利用帧对数据进行顺序标识，利用流进行数据并行传输")])]),v._v(" "),e("p",[v._v("主要改进点")]),v._v(" "),e("ol",[e("li",[v._v("头部压缩 -> 减少体积\n"),e("ul",[e("li",[v._v("采用"),e("code",[v._v("HPACK")]),v._v("压缩：利用服务器和客户端之间建立哈希表的映射，传递索引来精简和复用请求头部")])])]),v._v(" "),e("li",[v._v("二进制 + 分帧传输 -> 减少体积 + 提高安全性\n"),e("ul",[e("li",[v._v("由于 HTTP 的明文传输解析太过复杂（比如 "),e("code",[v._v("\\n")]),v._v(" 到底是换行还是字符串？），而且并不安全。所以，采用二进制进行传输")]),v._v(" "),e("li",[v._v("将数据以流的形式进行传输，并将请求和响应数据分割成更小的帧，而多个帧之间可以乱序发送，根据帧首部的流标识来重新组装。")])])]),v._v(" "),e("li",[v._v("多路复用 -> 解决队头阻塞\n"),e("ul",[e("li",[v._v("只需要占用一个 TCP 连接")])])]),v._v(" "),e("li",[v._v("服务器推送")])]),v._v(" "),e("p",[v._v("其他改动点")]),v._v(" "),e("ol",[e("li",[v._v("http2.0 只用于 https")])]),v._v(" "),e("h3",{attrs:{id:"关于-https"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于-https"}},[v._v("#")]),v._v(" 关于 HTTPS")]),v._v(" "),e("blockquote",[e("p",[v._v("HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 超文本传输"),e("strong",[v._v("安全")]),v._v("协议）")])]),v._v(" "),e("p",[v._v("HTTPS在传统的HTTP和TCP之间加了一层用于"),e("code",[v._v("加密解密的SSL/TLS层")]),v._v("（安全套接层Secure Sockets Layer/安全传输层Transport Layer Security）层。")]),v._v(" "),e("p",[v._v("PS: 当"),e("code",[v._v("SSL")]),v._v("发展到第三大版本时才被标准版，成为 "),e("code",[v._v("TLS")]),v._v("。即："),e("code",[v._v("TLS1.0 = SSL3.1")])]),v._v(" "),e("p",[v._v("HTTPS解决的问题")]),v._v(" "),e("ul",[e("li",[v._v("信息加密传输：第三方无法窃听；")]),v._v(" "),e("li",[v._v("校验机制：一旦被篡改，通信双方会立刻发现；")]),v._v(" "),e("li",[v._v("身份证书：防止身份被冒充。")])]),v._v(" "),e("p",[v._v("HTTPS在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输，使用HTTPS必须要有一套自己的数字证书（"),e("strong",[v._v("包含公钥和私钥")]),v._v("）。")]),v._v(" "),e("p",[v._v("HTTPS加密过程：")]),v._v(" "),e("ol",[e("li",[v._v("客户端请求服务器获取"),e("code",[v._v("证书公钥")]),v._v("（第三版返回的是数字证书，之前是直接返回的公钥）")]),v._v(" "),e("li",[v._v("客户端(SSL/TLS)解析证书（无效会弹出警告）")]),v._v(" "),e("li",[v._v("生成随机值")]),v._v(" "),e("li",[v._v("用"),e("code",[v._v("公钥加密")]),v._v("随机值生成"),e("strong",[v._v("密钥")])]),v._v(" "),e("li",[v._v("客户端将"),e("code",[v._v("秘钥")]),v._v("发送给服务器")]),v._v(" "),e("li",[v._v("服务端用"),e("code",[v._v("私钥")]),v._v("解密"),e("code",[v._v("秘钥")]),v._v("得到随机值")]),v._v(" "),e("li",[e("code",[v._v("将信息和随机值混合在一起")]),v._v("进行对称加密")]),v._v(" "),e("li",[v._v("将加密的内容发送给客户端")]),v._v(" "),e("li",[v._v("客户端用"),e("code",[v._v("秘钥")]),v._v("解密信息")])]),v._v(" "),e("p",[e("img",{attrs:{src:t(440),alt:"HTTPS"}})]),v._v(" "),e("p",[v._v("加密过程使用了对称加密和非对称加密。")]),v._v(" "),e("ul",[e("li",[v._v("对称加密: "),e("strong",[v._v("客户端和服务端采用相同的密钥经行加密")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("    encrypt(明文，秘钥) = 密文\n\n    decrypt(密文，秘钥) = 明文\n")])])])]),v._v(" "),e("li",[v._v("非对称加密："),e("strong",[v._v("客户端通过公钥加密。服务端通过私钥解密")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("    encrypt(明文，公钥) = 密文\n\n    decrypt(密文，私钥) = 明文\n")])])])])]),v._v(" "),e("p",[v._v("因为TLS握手的过程中采用了非对称加密，客户端本身不知道服务器的秘钥，这样通信就不会被中间人劫持。此外这一步服务端还提供了证书，并且可能要求客户端提供证书。关于证书下文会提到，只要有了证书，就能保证和你通信的对方是真实的，而不是别人伪造的。")]),v._v(" "),e("p",[v._v("那然后如何验证证书？")]),v._v(" "),e("ol",[e("li",[v._v("客户端获取到了站点证书，拿到了站点的公钥")]),v._v(" "),e("li",[v._v("客户端找到其站点证书颁发者的信息")]),v._v(" "),e("li",[e("code",[v._v("站点证书的颁发者")]),v._v("验证"),e("code",[v._v("服务端站点")]),v._v("是否可信")]),v._v(" "),e("li",[v._v("往上回溯，找到"),e("code",[v._v("根证书颁发者")])]),v._v(" "),e("li",[v._v("通过"),e("code",[v._v("根证书颁发者")]),v._v("一步步验证"),e("code",[v._v("站点证书颁布者")]),v._v("是否可信")])]),v._v(" "),e("p",[v._v("附：")]),v._v(" "),e("ul",[e("li",[v._v("HTTPS默认使用443端口，而HTTP默认使用80端口。")]),v._v(" "),e("li",[v._v("TLS就是从SSL发展而来的，只是SSL发展到3.0版本后改成了TLS")]),v._v(" "),e("li",[v._v("第一次请求中TLS握手的代价很大")]),v._v(" "),e("li",[v._v("后续的请求会共用第一次请求的协商结果")])]),v._v(" "),e("p",[v._v("参考：")]),v._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://www.jianshu.com/p/954961bac588",target:"_blank",rel:"noopener noreferrer"}},[v._v("刘某某_adf3"),e("OutboundLink")],1)]),v._v(" "),e("li",[e("a",{attrs:{href:"https://www.jianshu.com/p/24af67c40e8d",target:"_blank",rel:"noopener noreferrer"}},[v._v("jimsshom"),e("OutboundLink")],1)])]),v._v(" "),e("h3",{attrs:{id:"http-和-ajax-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-和-ajax-的区别"}},[v._v("#")]),v._v(" http 和 ajax 的区别")]),v._v(" "),e("p",[v._v("ajax：基于 "),e("code",[v._v("xmlHttpRequest")])]),v._v(" "),e("p",[v._v("http：基于 "),e("code",[v._v("httpRequest")])]),v._v(" "),e("p",[v._v("ps：ajax 请求头会多一个 "),e("code",[v._v("x-requested-with")]),v._v(" 参数，值为 "),e("code",[v._v("XMLHttpRequest")])]),v._v(" "),e("h3",{attrs:{id:"quic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#quic"}},[v._v("#")]),v._v(" QUIC")]),v._v(" "),e("p",[v._v("Google 研发了一种以 "),e("code",[v._v("UDP")]),v._v(" 为基础，能提供更可靠更高效的传输协议 "),e("code",[v._v("QUIC")]),v._v("，目前为止浏览器支持很有限。")]),v._v(" "),e("p",[v._v("可能成为 http3.0")]),v._v(" "),e("h3",{attrs:{id:"tcp慢启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp慢启动"}},[v._v("#")]),v._v(" TCP慢启动")]),v._v(" "),e("p",[v._v("最初的TCP的实现方式是，在连接建立成功后便会向网络中发送大尺寸的数据包，假如网络出现问题，很多这样的大包会积攒在路由器上，很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。")]),v._v(" "),e("p",[v._v("因此现在的TCP协议规定了，新建立的连接不能够一开始就发送大尺寸的数据包，而只能从一个小尺寸的包开始发送，在发送和数据被对方确认的过程中去计算对方的接收速度，来逐步增加每次发送的数据量（最后到达一个稳定的值，进入高速传输阶段。相应的，慢启动过程中，TCP通道处在低速传输阶段），以避免上述现象的发生。这个策略就是慢启动。")]),v._v(" "),e("h3",{attrs:{id:"关于cookie"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#关于cookie"}},[v._v("#")]),v._v(" 关于cookie")]),v._v(" "),e("p",[v._v("首先 http1.x 是无状态的，既然是无状态的那么就存在会话状态问题，比如：登录信息在客户端的留存。因此就出现了 cookie。")]),v._v(" "),e("p",[v._v("cookie 的属性：")]),v._v(" "),e("ul",[e("li",[v._v("Expires: 过期时间（缺省则浏览器关闭时清除）")]),v._v(" "),e("li",[v._v("Max-Age：失效前需要建立的毫秒数（优先级大于Expires）")]),v._v(" "),e("li",[v._v("Domain：指定的域名（这个域名不可跨域指定）")]),v._v(" "),e("li",[v._v("Path：指定path路径")]),v._v(" "),e("li",[v._v("Secure：只能通过 https 传递")]),v._v(" "),e("li",[v._v("HttpOnly：只能通过在http响应头中添加"),e("code",[v._v("Set-Cookie")]),v._v("时才能设置cookie，通过"),e("code",[v._v("document.cookie")]),v._v("设置无效")]),v._v(" "),e("li",[v._v("SameSite：在跨站请求时是否发送cookie\n"),e("ul",[e("li",[v._v("None：无论是否跨站都会发送 cookie")]),v._v(" "),e("li",[v._v("Lax：允许导航到目标网址的"),e("code",[v._v("get请求")]),v._v("发送cookie")]),v._v(" "),e("li",[v._v("Strict：最严格，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。")])])])]),v._v(" "),e("p",[v._v("ps：由于2020年2月chrome-v80更改了"),e("code",[v._v("SameSite")]),v._v(" 属性，默认屏蔽了第三方cookie（从 "),e("code",[v._v("None")]),v._v(" 改为 "),e("code",[v._v("Lax")]),v._v("），用以预防"),e("code",[v._v("CSRF")]),v._v(" 攻击，因此也导致很多大厂的跨域交互出现了问题，这时，网站可以选择显式关闭SameSite属性，将其设为None。前提是必须同时设置"),e("code",[v._v("Secure")]),v._v("属性，否则无效。")])])}),[],!1,null,null,null);_.default=o.exports}}]);