(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{620:function(e,r,s){"use strict";s.r(r);var t=s(54),a=Object(t.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"rxjs学习-之-observable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rxjs学习-之-observable"}},[e._v("#")]),e._v(" RXJS学习 之 Observable")]),e._v(" "),s("blockquote",[s("p",[e._v("Observable 是RXJS的核心")])]),e._v(" "),s("p",[e._v("Observable顾名思义:可观察的,用来给Observer订阅.")]),e._v(" "),s("p",[e._v("Observable必须要被订阅后才会进行运算")]),e._v(" "),s("p",[e._v("最简单的例子: (一般不这么用)")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  // 创建可观察对象\n  Observable.create(subscriber => {\n    subscriber.next('abc');\n    subscriber.complete();\n  })\n  // .map(v => v)\n  // .filter(v => true)\n  .subscribe(\n      v => { console.log(v) },\n      e => { console.log(e) },\n      () => { console.log('complete') }\n  );\n")])])]),s("p",[e._v("观察者有3个方法：（上述例子已使用）")]),e._v(" "),s("ol",[s("li",[e._v("next")]),e._v(" "),s("li",[e._v("error: 主动调用error方法会使用观察者的error方法,后续的观察者的方法会失效（原生JS可以执行）\n"),s("ul",[s("li",[e._v("throw new Error 也能触发 error事件")])])]),e._v(" "),s("li",[e._v("complete： 使用后，后续的观察者的方法会失效（原生JS可以执行）")])]),e._v(" "),s("h3",{attrs:{id:"转换为observer对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#转换为observer对象"}},[e._v("#")]),e._v(" 转换为Observer对象")]),e._v(" "),s("p",[e._v("一般使用"),s("code",[e._v("from, of, fromEvent")]),e._v("将数组、事件、Promise转换为Observer对象")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  of('abc', '123') // 打印 abc -> 123\n  // of([1, 2, 3]) // 打印 [1, 2, 3]\n  // from([1, 2, 3]) // 打印 1  ->  2  ->  3\n  // from(Promise.resolve('123')) // 类似于then\n  // fromEvent(document, 'click', true)\n  // fromEventPattern( // 同时具有注册监听及移除监听两种行为\n  //     (handler) => { // 监听\n  //         document.addEventListener('click', handler);\n  //     }, \n  //     (handler) => { // 移除\n  //         document.removeEventListener('click', handler);\n  //     }\n  // )\n  .subscribe(\n      console.log,\n      console.log,\n      () => console.log('完成')\n  )\n")])])]),s("h3",{attrs:{id:"与时间有关的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与时间有关的"}},[e._v("#")]),e._v(" 与时间有关的")]),e._v(" "),s("p",[s("code",[e._v("interval")]),e._v(" 和 "),s("code",[e._v("timer")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  interval(1000).subscribe(console.log);\n  // 0  1   2   3 .... 每秒加一\n\n  timer(3000, 1000).subscribe(console.log);\n  // 等待 3秒, 然后每秒加一\n\n  timer(3000).subscribe(console.log)\n  // 3秒后执行(仅一次)\n\n  // 都会返回 subscription\n  // 通过 subscription.unsubscribe释放\n\n  // 除了unsubscribe,也可以使用operators的takeUntil来完成操作\n")])])]),s("h3",{attrs:{id:"合并observer对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并observer对象"}},[e._v("#")]),e._v(" 合并Observer对象")]),e._v(" "),s("p",[s("strong",[e._v("concat")])]),e._v(" "),s("p",[e._v("和原生JS数组的concat方法类似，"),s("code",[e._v("concat")]),e._v("可以把多个"),s("code",[e._v("observable")]),e._v("实例合并成一个")]),e._v(" "),s("p",[s("strong",[e._v("要等待前一个 observable 完成(complete)，才会继续下一个")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  let source = of(0, 1);\n  let source2 = interval(1000).pipe(\n      skip(2),\n      take(2),\n    );\n  let source3 = from([4, 5]);\n  let example = concat(source, source2, source3)\n\n  example.subscribe(console.log)\n")])])]),s("p",[s("strong",[e._v("merge")])]),e._v(" "),s("p",[e._v("作用和concat类似。可以把多个"),s("code",[e._v("observable")]),e._v("实例合并成一个")]),e._v(" "),s("p",[e._v("不同："),s("strong",[e._v("执行下一个任务时，不需要等待前一个observable完成")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  let source = of(0, 1);\n  let source2 = interval(1000).pipe(\n      skip(2),\n      take(2),\n    );\n  let source3 = from([4, 5]);\n\n  let mergeExample = merge(source, source2, source3)\n  mergeExample.subscribe(console.log)\n")])])]),s("h3",{attrs:{id:"合并元素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#合并元素"}},[e._v("#")]),e._v(" 合并元素")]),e._v(" "),s("p",[e._v("zip：取每个 observable 相对位的元素")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  let x = of(1, 2, 3);\n  let y = of('a', 'b', 'c');\n  \n  zip(x, y, (x,y) => {return [x, y]}).subscribe(console.log)\n\n  // [1, \"a\"]\n  // [2, \"b\"]\n  // [3, \"c\"]\n")])])]),s("h3",{attrs:{id:"组合-observable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组合-observable"}},[e._v("#")]),e._v(" 组合 Observable")]),e._v(" "),s("p",[e._v("combineLatest： 组合最后一个元素，不匹配空的最后项。")]),e._v(" "),s("p",[e._v("可以用在运算多个因子的结果")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  let ct1 = timer(0, 1000).pipe(take(3));\n  let ct2 = timer(500, 1000).pipe(take(5));\n  let ct3 = of('a', 'b');\n\n  combineLatest(ct1, ct2, ct3).subscribe(console.log)\n\n  // [0, 0, 'b']\n  // [1, 0, 'b']\n  // [1, 1, 'b']\n  // [2, 1, 'b']\n  // [2, 2, 'b']\n  // [2, 3, 'b']\n  // [2, 4, 'b']\n")])])]),s("h3",{attrs:{id:"其他"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[e._v("#")]),e._v(" 其他")]),e._v(" "),s("ul",[s("li",[e._v("race(a, b, c) 竞速，类似于Promise.race()")]),e._v(" "),s("li",[e._v("range(num1, num2) 取范围num1-num2的值。")])])])}),[],!1,null,null,null);r.default=a.exports}}]);