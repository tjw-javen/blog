(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{621:function(e,r,s){"use strict";s.r(r);var t=s(54),a=Object(t.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"rxjs学习-之-scheduler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rxjs学习-之-scheduler"}},[e._v("#")]),e._v(" RXJS学习 之 Scheduler")]),e._v(" "),s("blockquote",[s("p",[e._v("Scheduler允许定义Observable将哪些执行上下文传递给其Observer的通知")])]),e._v(" "),s("h3",{attrs:{id:"调度器-scheduler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调度器-scheduler"}},[e._v("#")]),e._v(" 调度器：Scheduler")]),e._v(" "),s("p",[e._v("官网翻译：")]),e._v(" "),s("p",[e._v("什么是调度程序？调度程序控制订阅何时开始以及何时传递通知。它由三个部分组成。")]),e._v(" "),s("ul",[s("li",[e._v("调度程序是一种数据结构。它知道如何根据优先级或其他标准存储和排队任务。")]),e._v(" "),s("li",[e._v("调度程序是执行上下文。它表示执行任务的位置和时间（例如，立即执行，或者在另一个回调机制中，例如setTimeout或process.nextTick，或动画帧）。")]),e._v(" "),s("li",[e._v("调度程序具有（虚拟）时钟。它通过now()调度程序上的getter方法提供了“时间”的概念。在特定调度程序上调度的任务将仅遵循该时钟表示的时间。")])]),e._v(" "),s("h3",{attrs:{id:"使用-scheduler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用-scheduler"}},[e._v("#")]),e._v(" 使用 Scheduler")]),e._v(" "),s("p",[e._v("Scheduler一般在Operators中通过"),s("code",[e._v("observeOn(xxx)")]),e._v("使用，或者能接收"),s("code",[e._v("Scheduler")]),e._v("参数的方法（例如：of、from、interval、timer、concat、merge 等）中使用。")]),e._v(" "),s("p",[e._v("使用方法：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    of(1, 2, 3, 4).pipe(\n        observeOn(asyncScheduler), // 异步\n    ).subscribe(console.log)\n")])])]),s("ul",[s("li",[e._v("asapScheduler  // 同步")]),e._v(" "),s("li",[e._v("asyncScheduler // 异步")]),e._v(" "),s("li",[e._v("animationFrameScheduler // requestAnimationFrame")])])])}),[],!1,null,null,null);r.default=a.exports}}]);